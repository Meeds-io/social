/**
 * 
 */
package org.exoplatform.social.service.malwareDetection;

import java.util.HashMap;
import java.util.Map;

import org.exoplatform.services.log.ExoLogger;
import org.exoplatform.services.log.Log;
import org.exoplatform.social.service.malwareDetection.connector.MalwareDetectionServiceConnector;

/**
 * Is extended by all MalwareDetectionService connectors, and allows to build configuration needed by a list of connectors that is used for Malware detection.
 * 
 */
public class MalwareDetectionService {
  
  private Map<String, MalwareDetectionServiceConnector> connectors = new HashMap<String, MalwareDetectionServiceConnector>();
  private static final Log LOGGER = ExoLogger.getExoLogger(MalwareDetectionService.class);
  private static final String SLASH_SEPARATOR = "/";
  private static final String BACK_SLASH_SEPARATOR = "\\";
  
  public static final String FILES_CONNECTOR = "files";
  public static final String JCR_CONNECTOR = "jcr";
  
  /**
   * Add Malware detection Connector to the service
   * @param malwareDetectionServiceConnector the Malware detection Connector to add
   * @LevelAPI Experimental
   */
  public void addConnector (MalwareDetectionServiceConnector malwareDetectionServiceConnector) {
    addConnector(malwareDetectionServiceConnector, false);
  }
  
  /**
   * Add malware detection Connector to the service
   * @param malwareDetectionServiceConnector the malware detection connector to add
   * @param override equal true if we can override an existing connector, false otherwise
   * @LevelAPI Experimental
   */
  public void addConnector (MalwareDetectionServiceConnector malwareDetectionServiceConnector, Boolean override) {
    if (connectors.containsKey(malwareDetectionServiceConnector.getType()) && override.equals(false)) {
      LOGGER.error("Impossible to add connector {}. A connector with the same name has already been registered.", malwareDetectionServiceConnector.getType());
    } else {
      connectors.put(malwareDetectionServiceConnector.getType(), malwareDetectionServiceConnector);
      LOGGER.info("A Malware detection Connector has been added: {}", malwareDetectionServiceConnector.getType());
    }
  }
  
  /**
   * Gets all current connectors
   * @return Connectors
   * @LevelAPI Experimental
   */
  public Map<String, MalwareDetectionServiceConnector> getConnectors() {
    return connectors;
  }
  
  public void processInfectedItem(String infectedItemPath) {
    if (infectedItemPath.contains(getJcrNodePathSeparator(infectedItemPath) + FILES_CONNECTOR + getJcrNodePathSeparator(infectedItemPath))) {
      MalwareDetectionServiceConnector fileMalwareDetectionServiceConnector = (MalwareDetectionServiceConnector) getConnectors().get(FILES_CONNECTOR);
      if(fileMalwareDetectionServiceConnector != null && fileMalwareDetectionServiceConnector.isEnable()) {
        fileMalwareDetectionServiceConnector.sendInfectedItemNotification(infectedItemPath);
        fileMalwareDetectionServiceConnector.cleanInfectedItem(infectedItemPath);
      }
    }
    else if (infectedItemPath.contains(getJcrNodePathSeparator(infectedItemPath) + JCR_CONNECTOR + getJcrNodePathSeparator(infectedItemPath) + "values" + getJcrNodePathSeparator(infectedItemPath))) {
      MalwareDetectionServiceConnector jcrMalwareDetectionServiceConnector = (MalwareDetectionServiceConnector) getConnectors().get(JCR_CONNECTOR);
      if(jcrMalwareDetectionServiceConnector != null && jcrMalwareDetectionServiceConnector.isEnable()) {
        jcrMalwareDetectionServiceConnector.sendInfectedItemNotification(infectedItemPath);
        jcrMalwareDetectionServiceConnector.cleanInfectedItem(infectedItemPath);
      }
    }
  }
  
  public static String getJcrNodePathSeparator(String infectedFilePath) {
    String separator = "";
    if (infectedFilePath.contains(SLASH_SEPARATOR)) {
      separator = SLASH_SEPARATOR;
    }
    else if (infectedFilePath.contains(BACK_SLASH_SEPARATOR)) {
      separator = BACK_SLASH_SEPARATOR;
    }
    return separator;
  }
  
}